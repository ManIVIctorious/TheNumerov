#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <ctype.h>
#include <string.h>
#include <getopt.h>

#include "mkl_solvers_ee.h"

char          UPLO = 'F';

// used constants
//
// factor for -h_bar^2/2m for reduced mass in g
// h_bar                 1.05457180013E-34 Js
// Avogadro's constant   6.02214085774E23 1/mol
// atomic mass unit      1.66053904020E-27 kg
//
// Conversion factors    1.0E20          Ang^2 / m^2
//                       1.0 / 4184.0    kcal / J


//static int verbose_flag;

int main(int argc, char* argv[])
{
  int get_stencil(double stencil[], int n_stencil);
  int spline1d();

  double integrate_1d(int n, double dx, double integrand[]);

  int i, j, k, l;
  int control;
  int element;

  int line_number   = 0;

  int option_index  = 0;
  int n_points      = 0;
  int n_pot         = 0;
  int n_dip         = 0;
  int n_ts_dip      = 0;

  int n_stencil     = 9;
  int n_entries     = 0;
  int max_entries   = 0;

  int n_spline      = 0;
  int analyse       = 0;
  int set_zero      = 0;

  int * sign;

  double dq;
  double mass = 1.0;
  double ekin_param = -1.05457180013E-34 * 1.05457180013E-34 / 2.0 / 1.66053904020E-27 * 1.0E20 * 6.02214085774E23 / 4184.0;
  double kcal_per_mol_to_inv_cm = 219474.6313705/627.509469;

  double ekin_factor = 1.0;
  double epot_factor = 1.0;
  double e_min = 0.0;
  double e_max = 100.0;

  double v_min = 1.0E100;

  double dummy;
  double freq;
  double integral;
  double ts_dip_square;

  double * q = NULL;
  double * v = NULL;

  double * dip_x = NULL;
  double * dip_y = NULL;
  double * dip_z = NULL;

  double * ts_dip_x = NULL;
  double * ts_dip_y = NULL;
  double * ts_dip_z = NULL;

  double * stencil;
  double * integrand;

  char c;
  char line[2048];

  char *input_file_name  = NULL;
  char *dipole_file_name = NULL;
  char *output_file_name = "/dev/stdout";

  FILE * file_ptr;

  printf("\n\n");

  while (1)
    {
      static struct option long_options[] =
        {
	  {"help",             no_argument, 0, 'h'},
          {"mass",       required_argument, 0, 'm'},
          {"fkin",       required_argument, 0, 'k'},
          {"fpot",       required_argument, 0, 'v'},
          {"n_stencil",  required_argument, 0, 'n'},
          {"e_min",      required_argument, 0, 'l'},
          {"e_max",      required_argument, 0, 'u'},
          {"spline",     required_argument, 0, 's'},
          {"zero",             no_argument, 0, 'z'},
          {"analye",           no_argument, 0, 'a'},
          {"dipole",     required_argument, 0, 'd'},
          {"in-file",    required_argument, 0, 'i'},
          {"out-file",   required_argument, 0, 'o'},
	  { 0, 0, 0, 0 }
        };
      /* getopt_long stores the option index here. */

      i = getopt_long (argc, argv, "hm:k:v:n:l:u:s:zad:i:o:", long_options, &option_index);

      /* Detect the end of the options. */
      if (i == -1)
        break;

      switch (i)
        {
        case 0:
          /* If this option set a flag, do nothing else now. */
          if (long_options[option_index].flag != 0)
            break;
          printf ("option %s", long_options[option_index].name);
          if (optarg)
            printf (" with arg %s", optarg);
          printf ("\n");
          break;

	  //case 'h':
	  //    Help(argv[0], 0);
	  //    exit (0);

	case 'm':
	  mass = atof(optarg);
	  break;

	case 'k':
	  ekin_factor = atof(optarg);
	  break;

	case 'v':
	  epot_factor = atof(optarg);
	  break;
	  
	case 'n':
	  n_stencil = atoi(optarg);
	  break;

	case 'l':
	  e_min = atof(optarg);
	  break;

	case 'u':
	  e_max = atof(optarg);
	  break;

	case 's':
	  n_spline = atoi(optarg);
	  break;

	case 'z':
	  set_zero = 1;
	  break;

	case 'a':
	  analyse = 1;
	  break;

	case 'd':
	  dipole_file_name = optarg;
	  break;

	case 'i':
	  input_file_name = optarg;
	  break;

	case 'o':
	  output_file_name = optarg;
	  break;

        default:
          printf("\n\n (-) Unkown flag %d - aborting. Please check your input.\n\n\n", option_index);
          exit (-1);
        }
    }


  // check input argument if the file is not present give a silly statement
  if (input_file_name == NULL) 
  { 
    printf("\n\n (-) Please specify an input file ... \n\n");
    exit (1);
    // usage
  }

  // get stencil
  stencil = (double *) malloc(n_stencil * sizeof(double) );
  control = get_stencil(stencil, n_stencil);

  if (control != 1)
  {
    printf("\n\n (-) Error initialising stencil parameters.");

    if (n_stencil%2 == 0)
     printf("\n     Stencil size is given as even (%d), but must be an odd number.", n_stencil);
    else
      printf("\n     No data for %d-point stencial available.", n_stencil);

    printf(  "\n     Aborting - please check your input ... \n\n\n");

    exit(-1);
  }

  // get memory and read input data 
  q  = (double *) malloc( sizeof(double) );
  v  = (double *) malloc( sizeof(double) );

  if ( (file_ptr = fopen(input_file_name,"r")) == NULL)
  {  
    printf("\n\n (-) Error opening input-file: '%s'", input_file_name);
    printf(  "\n     Exiting ... \n\n");

    exit(0);
  } 

  while ( (fgets(line, 2048, file_ptr) ) != NULL )
  {
    line_number ++;

    // remove leading white space
    // remove leading blanks and tabs  
    i=0;
    do 
    {
      c=line[i];
      if ((c == ' ') || (c == '\t'))  
	for (j = i; j < strlen(line) ; j++)        
	  line[j] = line[j+1];
      else 
	i++;        
    }
    while (c == ' '); 

    // if line is  blank read next line 
    if (line[0] == '\n') continue;

    // if line is a comment read next line 
    if (line[0] == '#') continue;

    q  = (double *) realloc(q, (n_pot + 1) * sizeof(double) );
    v  = (double *) realloc(v, (n_pot + 1) * sizeof(double) );
     
    control=sscanf(line,"%lf  %lf", &q[n_pot], &v[n_pot]);

    if (control != 2)
    {
      printf("\n\n (-) Error reading data from input-file: '%s' in line %d.", input_file_name, line_number);
      printf(  "\n     Aborting - please check your input ... \n\n\n");

      exit(0);
    }

    if (v[n_pot] < v_min)
    {
      v_min = v[n_pot];
    }

    n_pot ++;
  }

  fclose(file_ptr);

  // number of points vs stencil
  if (n_pot < n_stencil )
  {
      printf("\n\n (-) Error reading data from input-file: '%s'", input_file_name);
      printf(  "\n     Insufficient number of data points %d for stencial size %d.", n_pot, n_stencil);
      printf(  "\n     Aborting - please check your input ... \n\n\n");

      exit(0);
  }

  // set potential to zero
  if(set_zero == 1)
  {
    for (i = 0; i < n_pot; i++)
    {
      v[i] = v[i] - v_min;
    }
  }









  // Cubic spline interpolation of the potential 
  if (n_spline > 0)
  {
    i = (n_pot - 1) * (n_spline + 1) + 1;

    q = (double *) realloc(q, i * sizeof(double) );
    v = (double *) realloc(v, i * sizeof(double) );

    spline1d(n_pot, n_spline, q, v);

    n_points = i;
  }
  else
  {
    n_points = n_pot;
  }

  // get spacing intervall dx and check uniform spacing
  dq = q[1] - q[0];

  for (i = 1; i < n_points-1; i++)
  {
     if ( fabs(q[i+1] - q[i] - dq) > 1.0E-12)
    {
      printf("\n\n (-) Error reading data from input-file: '%s'", input_file_name);
      printf(  "\n     Data not uniformly spaced. Exiting ... \n\n");

      exit(0);
    }
  }

  // apply kinetic energy factor and spacing to ekin_param
  ekin_param = ekin_param * ekin_factor / dq / dq / mass; 

  // read dipole
  if (dipole_file_name != NULL)
  {

    if ( (file_ptr = fopen(dipole_file_name,"r")) == NULL)
    {  
      printf("\n\n (-) Error opening dipole-file: '%s'", dipole_file_name);
      printf(  "\n     Exiting ... \n\n");

      exit(0);
    } 

    dip_x  = (double *) malloc( sizeof(double) );
    dip_y  = (double *) malloc( sizeof(double) );
    dip_z  = (double *) malloc( sizeof(double) );

    line_number = 0;

    while ( (fgets(line, 2048, file_ptr) ) != NULL )
    {
      line_number ++;

      // remove leading white space
      // remove leading blanks and tabs  
      i = 0;
      do 
      {
	c=line[i];
	if ((c == ' ') || (c == '\t'))  
	  for (j = i; j < strlen(line) ; j++)        
	    line[j] = line[j+1];
	else 
	  i++;        
      }
      while (c == ' '); 

      // if line is  blank read next line 
      if (line[0] == '\n') continue;

      // if line is a comment read next line 
      if (line[0] == '#') continue;

      dip_x  = (double *) realloc(dip_x, (n_dip + 1) * sizeof(double) );
      dip_y  = (double *) realloc(dip_y, (n_dip + 1) * sizeof(double) );    
      dip_z  = (double *) realloc(dip_z, (n_dip + 1) * sizeof(double) );
 
      control=sscanf(line,"%lf  %lf  %lf  %lf", &dummy, &dip_x[n_dip], &dip_y[n_dip], &dip_z[n_dip]);

      if (control != 4)
      {
	printf("\n\n (-) Error reading data from dipole-file: '%s' in line %d.", dipole_file_name, line_number);
	printf(  "\n     Aborting - please check your input ... \n\n\n");

	exit(0);
      }

      n_dip ++;
    }
  
    if (n_dip != n_pot)
    {
      printf("\n\n (-) Error reading data from dipole-file: '%s'.", dipole_file_name, line_number);
      printf(  "\n     Mismatch of data-points (%d) with number of potential points (%d).", n_pot, n_dip);
      printf(  "\n     Aborting - please check your input ... \n\n\n");

      exit(0);
    }


    // Cubic spline interpolation of the potential 
    if (n_spline > 0)
    {
      i = (n_dip - 1) * (n_spline + 1) + 1;

      dip_x  = (double *) realloc(dip_x, i * sizeof(double) );
      dip_y  = (double *) realloc(dip_y, i * sizeof(double) );
      dip_z  = (double *) realloc(dip_z, i * sizeof(double) );

      spline1d(n_dip, n_spline, q, dip_x);
      spline1d(n_dip, n_spline, q, dip_y);
      spline1d(n_dip, n_spline, q, dip_z);
    }

  } // if (dipole_file_name != NULL)


  // request MKL types
    char          UPLO = 'F'; 
    const MKL_INT N = n_points;
    MKL_INT       rows_A[n_points+1];

    rows_A[0] = 1;

    //printf("\nrows_A[0]=%d",rows_A[0]);

    for (i = 0; i < n_stencil/2; i++)
    {
      rows_A[i+1] = rows_A[i] + n_stencil/2 + 1 + i;

      //printf("\nrows_A[%d]=%d",i+1,rows_A[i+1]);
    }

    for (i=n_stencil/2+1; i < n_points + 1 - n_stencil/2; i++)
    {
      rows_A[i] = rows_A[i-1] + n_stencil;
      //printf("\nrows_A[%d]=%d",i,rows_A[i]);

    }

    for (i=n_points-n_stencil/2+1; i < n_points + 1; i++)
    {
      rows_A[i] = rows_A[i-1] + n_stencil - n_stencil/2 + n_points -i;
      //printf("\nrows_A[%d]=%d",i,rows_A[i]);
    }

    // calculate n_entries
    for (i = n_stencil/2+1; i < n_stencil; i++)
    {
      max_entries = max_entries + 2*i;
    }

    max_entries = max_entries + n_stencil * (n_points - n_stencil + 1);

    MKL_INT       cols_A[max_entries];
    double        vals_A[max_entries];

    for (i = 0; i < n_points; i++)
    {
      for (j = -n_stencil/2; j < n_stencil/2 + 1; j++)
      {

        element = i + j;

	if ( (element > -1) && ( element < n_points))
	{

	  cols_A[n_entries] = element+1;

          vals_A[n_entries] = ekin_param * stencil[j+n_stencil/2];

	  // add potential to diagonal element         
          if (j == 0)
	  {
	    vals_A[n_entries] = vals_A[n_entries] + v[i] * epot_factor; 

	    //  printf("potential added   %20.8lf", vals_A[n_entries]);
	  }

          n_entries ++;
	}
      }
    }

    //printf("\n  %d     %d\n", max_entries, n_entries);

    MKL_INT      fpm[128];      /* Array to pass parameters to Intel MKL Extended Eigensolvers */
    //    double       Emin, Emax;    /* Lower/upper bound of search interval [Emin,Emax] */

    double       epsout;        /* Relative error on the trace */
    MKL_INT      loop;          /* Number of refinement loop */
    MKL_INT      L = n_points/2;
    MKL_INT      M0;            /* Initial guess for subspace dimension to be used */
    MKL_INT      n_out = 5;



    double       E[n_points];         /* Eigenvalues */

    double *X;

    X = calloc (n_points*(n_points-1)/2, sizeof (double));  /* Eigenvectors */

    double       res[n_points];       /* Residual */

    MKL_INT      info;          /* Errors */

    char         SGEMMC = 'T';   /* Character for GEMM routine, transposed case */
    char         SGEMMN = 'N';   /* Character for GEMM routine, non-transposed case */
    double       one = 1.0;      /* alpha parameter for GEMM */
    double       zero = 0.0;     /* beta  parameter for GEMM */
    MKL_INT      ldx = n_points; /* Leading dimension for source arrays in GEMM */
    MKL_INT      ldy = n_points; /* Leading dimension for destination array in GEMM */

    double       trace, smax, eigabs;

    M0    = L;
    n_out = L;
    loop  = 0;
    info  = 0;
    epsout = 0.0;

    feastinit(fpm); /* OUT: Array is used to pass parameters to Intel MKL Extended Eigensolvers */

    dfeast_scsrev(
        &UPLO,   /* IN: UPLO = 'F', stores the full matrix */
        &N,      /* IN: Size of the problem */
        vals_A,  /* IN: CSR matrix A, values of non-zero elements */
        rows_A,  /* IN: CSR matrix A, index of the first non-zero element in row */
        cols_A,  /* IN: CSR matrix A, columns indices for each non-zero element */
        fpm,     /* IN/OUT: Array is used to pass parameters to Intel MKL Extended Eigensolvers */
        &epsout, /* OUT: Relative error of on the trace */
        &loop,   /* OUT: Contains the number of refinement loop executed */
        &e_min,   /* IN: Lower bound of search interval */
        &e_max,   /* IN: Upper bound of search interval */
        &M0,     /* IN: The initial guess for subspace dimension to be used. */
        E,       /* OUT: The first M entries of Eigenvalues */
        X,       /* IN/OUT: The first M entries of Eigenvectors */
        &n_out,  /* OUT: The total number of eigenvalues found in the interval */
        res,     /* OUT: The first n_out components contain the relative residual vector */
        &info    /* OUT: Error code */
        );

    // Error output
    if ( info != 0 )
    {
        printf(" (-) Routine sfeast_scsrev returns code of ERROR: %i\n\n\n", (int)info);
        return 1;
    }

    // get norm
    integrand = (double *) calloc(n_points, sizeof(double) ); 

    for (i = 0; i < n_out; i++)
    {

      for (j = 0; j < n_points-1; j++)
      {
        integrand[j] = X[j+i*n_points] * X[j+i*n_points];
      }

      integral = integrate_1d(n_points, dq, integrand);

      for (j = 0; j < n_points-1; j++)
      {
	X[j+i*n_points] = X[j+i*n_points] / sqrt(integral);
      }
  }

  if ( (file_ptr = fopen(output_file_name,"w")) == NULL)
  {  
    printf("\n\n (-) Error opening output-file: '%s'", output_file_name);
    printf(  "\n     Exiting ... \n\n");

    exit(0);
  } 

  // Output eigenvalues
  fprintf(file_ptr, "# Eigenvalues");

  for (i=0; i < n_out; i++)
  {
    fprintf(file_ptr, "  %24.16lf", i, E[i]);
  }

  fprintf(file_ptr, "\n# Mass         %24.16lf", mass);

  fprintf(file_ptr,"\n#");

    fprintf(file_ptr, "\n# Frequencies:\n#");
    
    fprintf(file_ptr, "\n# ");

    for (i = 0; i < (n_out - 1); i++)
      fprintf(file_ptr,"%11d   ", i);

    element = 0;
    for (i = 1; i < n_out; i++)
    {
      fprintf(file_ptr, "\n#%3d",i);

      for (j = 0; j < i; j++)
      {
	freq = 219474.6313705/627.509469 * epot_factor * (E[i] - E[j]);
	fprintf(file_ptr, "  %12.5e", freq);
      }
  }


  if (analyse == 1)
  {
    // Orthogonality output

    fprintf(file_ptr, "\n#");
    
    fprintf(file_ptr, "\n# Orthonormality:\n#");
    
    fprintf(file_ptr, "\n# ");
    
    for (i=0; i < n_out; i++)
      fprintf(file_ptr,"%11d   ", i);
    
    for (i = 0; i < n_out; i++)
    {
      fprintf(file_ptr, "\n#%3d",i);
      
      for (j = 0; j < (i+1); j++)
      {
	for (k = 0; k < n_points; k++)
        {
	  // generate integrand
	  integrand[k] = X[k+i*n_points]*X[k+j*n_points];
	}
       
	integral = integrate_1d(n_points, dq, integrand);

	fprintf(file_ptr, "  %12.5e", integral);
      }
    }
    fprintf(file_ptr, "\n#");

    // Potential output

    fprintf(file_ptr, "\n#");

    fprintf(file_ptr, "\n# Potential:\n#");

    fprintf(file_ptr, "\n# ");

    for (i=0; i < n_out; i++)
      fprintf(file_ptr,"%11d   ", i);

    for (i = 0; i < n_out; i++)
    {
      fprintf(file_ptr, "\n#%3d",i);

      for (j = 0; j < (i+1); j++)
      {
	for (k = 0; k < n_points; k++)
        {
	  // generate integrand
	  integrand[k] = X[k+i*n_points]*X[k+j*n_points] * v[k];
	}
       
	integral = integrate_1d(n_points, dq, integrand);

	fprintf(file_ptr, "  %12.5e", integral);
      }
    }
    fprintf(file_ptr, "\n#\n#");

    // kinetic energy output

    fprintf(file_ptr, "\n# Kinetic Energy:\n#");

    fprintf(file_ptr, "\n# ");

    for (i=0; i < n_out; i++)
      fprintf(file_ptr,"%11d   ", i);

    for (i = 0; i < n_out; i++)
    {
      fprintf(file_ptr, "\n#%3d",i);

      for (j = 0; j < (i+1); j++)
      {

	for (k = 0; k < n_points; k++)
        {
	 // reset integrand because
	 // ekin-operator has to be applyed via a loop
	 integrand[k] = 0.0;

	 // apply stencil
         for (l = 0; l < n_stencil + 1; l++)
	 {
	   element = k+l-n_stencil/2;

	   if ( (element > -1) && (element < (n_points +1) ) )
	   {
	     integrand[k] = integrand[k] + X[element+i*n_points] * stencil[l]; 
	   }
	 }

	 integrand[k] = ekin_param * integrand[k] * X[k+j*n_points];

	}

	integral = integrate_1d(n_points, dq, integrand);

	fprintf(file_ptr, "  %12.5e", integral);
      }
    }

    fprintf(file_ptr,"\n#");

  }// if (analyse == 1)

  if (dipole_file_name != NULL)
  {

    n_ts_dip = n_out * (n_out)/2;

    ts_dip_x = (double *) malloc( n_ts_dip * sizeof(double) ); 
    ts_dip_y = (double *) malloc( n_ts_dip * sizeof(double) ); 
    ts_dip_z = (double *) malloc( n_ts_dip * sizeof(double) ); 

    fprintf(file_ptr, "\n#");

    fprintf(file_ptr, "\n# Dipole - x-component\n#");

    fprintf(file_ptr, "\n# ");

    for (i=0; i < n_out; i++)
      fprintf(file_ptr,"%11d   ", i);

    element = 0;

    for (i = 0; i < n_out; i++)
    {
      fprintf(file_ptr, "\n#%3d",i);

      for (j = 0; j < (i+1); j++)
      {
	for (k = 0; k < n_points; k++)
        {
	  // generate integrand
	  integrand[k] = X[k+i*n_points]*X[k+j*n_points] * dip_x[k];
	}
       
	integral = integrate_1d(n_points, dq, integrand);

	fprintf(file_ptr, "  %12.5e", integral);

	if (i != j)
	{
	  ts_dip_x[element] = integral;
	  element ++;
	}
      }
    }
    fprintf(file_ptr, "\n#\n#");

    fprintf(file_ptr, "\n# Dipole - y-component\n#");

    fprintf(file_ptr, "\n# ");

    for (i = 0; i < n_out; i++)
      fprintf(file_ptr,"%11d   ", i);

    element = 0;

    for (i = 0; i < n_out; i++)
    {
      fprintf(file_ptr, "\n#%3d",i);

      for (j = 0; j < (i+1); j++)
      {
	for (k = 0; k < n_points; k++)
        {
	  // generate integrand
	  integrand[k] = X[k+i*n_points]*X[k+j*n_points] * dip_y[k];
	}
       
	integral = integrate_1d(n_points, dq, integrand);

	fprintf(file_ptr, "  %12.5e", integral);

	if (i != j)
	{
	  ts_dip_y[element] = integral;
	  element ++;
	}
      }
    }
    fprintf(file_ptr, "\n#\n#");

    fprintf(file_ptr, "\n# Dipole - z-component\n#");

    fprintf(file_ptr, "\n# ");

    for (i = 0; i < n_out; i++)
      fprintf(file_ptr,"%11d   ", i);

    element = 0;

    for (i = 0; i < n_out; i++)
    {
      fprintf(file_ptr, "\n#%3d",i);

      for (j = 0; j < (i+1); j++)
      {
	for (k = 0; k < n_points; k++)
        {
	  // generate integrand
	  integrand[k] = X[k+i*n_points]*X[k+j*n_points] * dip_z[k];
	}
       
	integral = integrate_1d(n_points, dq, integrand);

	fprintf(file_ptr, "  %12.5e", integral);

	if (i != j)
	{
	  ts_dip_z[element] = integral;
	  element ++;
	}
      }
    }
    fprintf(file_ptr, "\n#\n#");

    fprintf(file_ptr, "\n# Oscillator strength\n#");

    fprintf(file_ptr, "\n# ");

    for (i = 0; i < (n_out - 1); i++)
      fprintf(file_ptr,"%11d   ", i);

    element = 0;
    for (i = 1; i < n_out; i++)
    {
      fprintf(file_ptr, "\n#%3d",i);

      for (j = 0; j < i; j++)
      {
	ts_dip_square =  ts_dip_x[element] * ts_dip_x[element] + ts_dip_y[element] * ts_dip_y[element]+ ts_dip_z[element] * ts_dip_z[element];

	freq = 219474.6313705/627.509469 * epot_factor * (E[i] - E[j]);

	fprintf(file_ptr, "  %12.5e", 4.702E-7 * ts_dip_square * freq);
	//fprintf(file_ptr, "  %12.5e", ts_dip_z[element]);

	element ++;
      }
    ///////////////////
    
    }
    fprintf(file_ptr, "\n#\n#");
  }


  fprintf(file_ptr,"\n# Potential and Eigenfunctions: %d datapoints\n", n_points);

  // Output eigenfunctions
  for (i = 0; i < n_points; i++)
  {

    fprintf(file_ptr,"%24.16lf    %24.16lf", q[i], v[i]);
    
    for (j=0; j<n_out; j++)
    {
      fprintf(file_ptr, "  %24.16lf", E[j] + X[i+j*n_points]);
    }
    
    fprintf(file_ptr,"\n");
  }
  
  fprintf(file_ptr,"\n\n");
  
  fclose(file_ptr);
  
  
  printf("\n\n");
  
  exit (0);
}










double integrate_1d(int n, double dx, double integrand[])
{
  int i;

  double integral = 0.0;

  integral = 0.5*(integrand[0] + integrand[n-1]);

  for (i = 1; i < (n-1); i++)
  {

    integral = integral + integrand[i];
  }

  return integral * dx;
}
